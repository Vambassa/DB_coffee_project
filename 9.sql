SET SEARCH_PATH = coffee_project;

-- 1
-- При поступлении нового заказа, считаем общее количество заказов у данного покупателя
-- и количество заказов в этом же магазине. Если оно превышает 50%, то 
-- устанавливаем этот магазин любимым для покупателя
-- и добавляем в историю покупателя информацию о предыдущем любимом магазине
CREATE OR REPLACE FUNCTION проверить_и_обновить_покупателя()
RETURNS TRIGGER AS $$
DECLARE
    заказы_в_id_магазин INTEGER;
    общее_колво_заказов INTEGER;
   	покупатель_инфо RECORD;
BEGIN
	SELECT COUNT(*) into заказы_в_id_магазин
	FROM заказ
	WHERE id_магазин = NEW.id_магазин AND id_покупатель = new.id_покупатель;

							
	SELECT COUNT(*)	into общее_колво_заказов
	FROM заказ
	WHERE id_покупатель = NEW.id_покупатель;		
  					
    SELECT INTO покупатель_инфо имя, фамилия, номер_телефона, id_любимый_магазин
    FROM покупатель
    WHERE id_покупатель = NEW.id_покупатель;

    IF заказы_в_id_магазин * 2 > общее_колво_заказов THEN
        UPDATE покупатель
        SET id_любимый_магазин = NEW.id_магазин
        WHERE id_покупатель = NEW.id_покупатель;
       
       INSERT INTO покупатель_история (имя, фамилия, номер_телефона, id_любимый_магазин, id_покупатель)
        VALUES (покупатель_инфо.имя, покупатель_инфо.фамилия, покупатель_инфо.номер_телефона, покупатель_инфо.id_любимый_магазин, new.id_покупатель);
       
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER после_вставки_в_заказ
AFTER INSERT ON заказ
FOR EACH ROW
EXECUTE FUNCTION проверить_и_обновить_покупателя();


-- демонстрация 1

SELECT * FROM покупатель;

SELECT * FROM покупатель_история;

SELECT * FROM заказ WHERE id_покупатель = 1;

INSERT INTO заказ (сумма, дата, статус, id_покупатель, id_магазин)
values (11232, '2023-12-13 10:00:00', 'В обработке', 1, 1);

-- после этого заказа должно произойти обновление любимого магазина
INSERT INTO заказ (сумма, дата, статус, id_покупатель, id_магазин)
values (11232, '2023-12-14 10:00:00', 'В обработке', 1, 1);



-- 2
-- При поступлении заказа, проверяем, что на складе достаточно товара,
-- если нет -- отменяем заказ
CREATE OR REPLACE FUNCTION проверить_наличие()
RETURNS TRIGGER AS $$
DECLARE
   	магазин INTEGER;
    колво_в_наличии INTEGER;
BEGIN
   	магазин := (SELECT id_магазин
   				FROM заказ
   				WHERE id_заказ = NEW.id_заказ);
   	колво_в_наличии := (SELECT количество_товара
   						FROM товар_в_наличии
   						WHERE id_магазин = магазин
   						AND id_упаковка_кофе = new.id_упаковка_кофе);
   
   	IF NEW.количество_товара > колво_в_наличии THEN
        UPDATE заказ
        SET статус = 'Отменен'
        WHERE id_заказ = NEW.id_заказ;
       return null;
    END IF;
   

    UPDATE товар_в_наличии
    SET количество_товара = количество_товара - NEW.количество_товара
    WHERE id_магазин = магазин 
   		AND id_упаковка_кофе = NEW.id_упаковка_кофе;
   	
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE TRIGGER проверить_заказ
BEFORE INSERT ON заказ_кофе
FOR EACH ROW
EXECUTE FUNCTION проверить_наличие();


-- демонстрация 2
INSERT INTO упаковка_кофе (название_сорта, страна, метод_обработки, уровень_обжарки, стоимость)
VALUES ('Коста-Рика Сан Хосе', 'Коста-Рика', 'Мытая', 'Темная', '3500');

INSERT INTO товар_в_наличии (id_магазин, id_упаковка_кофе, количество_товара) VALUES (1, 16, 10);

SELECT * FROM товар_в_наличии WHERE id_магазин = 1 AND id_упаковка_кофе = 16;

INSERT INTO заказ (id_заказ, сумма, дата, статус, id_покупатель, id_магазин)
VALUES (35, 10000, CURRENT_TIMESTAMP, 'В обработке', 1, 1);

-- недостаток на складе
INSERT INTO заказ_кофе (id_заказ, id_упаковка_кофе, количество_товара)
VALUES (35, 16, 500);

-- хватает
INSERT INTO заказ_кофе (id_заказ, id_упаковка_кофе, количество_товара)
VALUES (35, 16, 5);


SELECT * FROM заказ_кофе;
SELECT * FROM заказ;
SELECT * FROM товар_в_наличии WHERE id_магазин = 1 AND id_упаковка_кофе = 16;


delete FROM заказ WHERE id_заказ = 35;
delete FROM заказ_кофе WHERE id_заказ = 35;



